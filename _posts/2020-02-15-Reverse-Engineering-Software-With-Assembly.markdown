---
title: "Reverse Engineering Software with Assembly Language"
categories: reverse-engineering debugging programming assembly
excerpt: "
So you have some program/software and you dont know exactly what it does, maybe
the code is proprietary thus you cant read the code and figure it out, you want
to inspect a piece of malicious software/virus."
---
# WHY REVERSE ENGINEER?
So you have some program/software and you dont know exactly what it does, maybe
the code is proprietary thus you cant read the code and figure it out, you want
to inspect a piece of malicious software/virus.
Here is why you might want to do some RE:

-   To achieve Interoperability Make some system work with software or
    hardware you already have
-   To figure out how it works
-   Keygen/Cracks
-   Exploit Development
-   Proprietary File Formats

## Assumptions
Before Proceeding It is important that the reader have some knowledge of the following concepts:

1. Endianness

2. Data structures

3. Hexadecimal notation

4. Intel Architecture

# Assembly Language
A very low level programming language generated by compilers and translatable to
machine code directly. Offers more control but less abstraction and would
require alot of typing.
The goal is not to write programs in assembly code though i have written some
basic bootloaders with assembly you can check out the [project
here](https://github.com/TralahM/explore_asm) but to be able to read and
understand disassembled code from a piece of software you want to reverse
engineer.

## The Stack Data Structure

-   LIFO data structure

```nasm
push ebp
mov esp,ebp
sub esp,0x08
mov eax,45
mov ebx,43
add eax,ebx
call sym_add
ret
```

## The Heap

Associated with Dynamic memory allocation

## The BSS Section

Contains all Uninitialized variables

## The Text Section

Contains the actual executable instructions( code )

## The Registers

### General Purpose

1.  __EAX__ return values
2.  __EBX__ Base register for memory access
3.  __ECX__ Loop Counter
4.  __EDX__ Data Register for I/O

### Segment Registers

Usually are named with Two letter abbreviations

1. __CS__ Stores code segment

2.  __DS__ Stores Data segment
3.  __ES__,__FS__,__GS__ Far addressing (video mem etc)
4.  __SS__ Stack segment usually same as __EDX__

### Indexes and Pointers

1.  __EDI__ Destination index register for array ops
2.  __ESI__ Source index register array ops
3.  __EBP__ Base Pointer bottom of stack frame
4.  __ESP__ Stack Pointer top of stack frame
5.  __EIP__ Instruction Pointer to next instruction to be executed

The __E__ prefix is for 32-bit, 16-bit and 8-bit are without the E prefix
and finally for 64-bit the prefix is __R__ instead of E however, forward
compatibility is maintained

### Flags Register

Holds 32 registers in total One bit values

1.  __ZF__ Zero Flag Set to 1 if result of previous op is 0
2.  __SF__ Sign Flag Set to 1 if result of previous op is negative -

## Calling Conventions

### CDECL

Arguments are passed on the stack in __Right-to-Left__ order

Return Values are passed to __EAX__

The Calling Function cleans the stack

Allowing for Variadic functions as caller knows the number of arguments

### STDCALL (AKA WINAPI)

Arguments are passed on the stack in __Right-to-Left__ order

Return Values are passed to __EAX__

The Called Function cleans the stack

### FASTCALL

The first 2 or 3 (32-bit or smaller ) arguments are passed directly in
registers with the most commonly used registers being __EDX__, __EAX__, and __ECX__ .

The Calling Function (usually) cleans the stack

### THISCALL (C++)

Only Non-Static Member Functions. Also Non-Variadic

The Pointer to the class object is passed in __ECX__, and return value is passed to __EAX__.

The Called Function cleans the Stack

OPERAND TYPES
-------------

-   __Immediates__ :03xf
-   __Registers__ :EAX,\....ECX the values themselves
-   __Memory adrresses__ \[0x80542a\], \[eax\]
-   __Offset Types__ by bytes \[eax + 0x4\]
-   __Sibs__ which are offsets by multiplication and addition \[ eax \* 4 + ecx \] , \[eax \* 2 + ecx\]

### OPS

-   __mov__ Move destination, source reg,mem,immediate any combination
-   __add__,sub addition and subtraction
-   __cmp__ compare subtract source from destination and assign a flag if ZF
    is 1 the destination and source are equivalent
-   __test__ test does bitwise and of source and destination and assigns a
    flag to ZF or SF depending on the result
-   __jcc__/__jmp__ conditional and regular jumps __jz__/__jnz__ if __ZF__ is zero or not
    __jump__ __ja__/__jae__ jump above and jump above equal __jb__/__jbe__/__bjnb__ jump below
    and jump below equal
-   __push__/__pop__ one operand and operate on stack
-   __bitwise ops__ :   and, or , xor, not

# Recognizing Programming Constructs

__Function Prologue and Epilogue__

``` nasm
push ebp
mov ebp, esp
sub esp, N

...
mov esp,ebp
pop ebp
ret
```

## About CALL and RET

Have an Implicit Operation
__Call__ will push EIP onto the Stack while  __Return__ will
pop the EIP pointer from the stack

## LOOPS

__ECX__ is usually loop counter conditional jumps based on loop counter
easier to spot in call graphs

## SWITCH STATEMENTS
jmp dwords endian formatted mem addressess with controlled offsets

# Winding Up
Hopefully now you are familiar with some basic assembly language syntax and are
now able to identify common programming structures like loops, switches,
functions etc from some disassembled binary code.
In the future we will look at how to get this assembly code from compiled
binaries as well as how to do some practical reverse engineering.
