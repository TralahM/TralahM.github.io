I"ì!<h1 id="why-reverse-engineer">WHY REVERSE ENGINEER?</h1>
<p>So you have some program/software and you donâ€™t know exactly what it does, maybe
the code is proprietary thus you cant read the code and figure it out, you want
to inspect a piece of malicious software/virus.
Here is why you might want to do some RE:</p>

<ul>
  <li>
    <p>To achieve Interoperability Make some system work with software or
hardware you already have</p>
  </li>
  <li>
    <p>To figure out how it works</p>
  </li>
  <li>
    <p>Keygen/Cracks</p>
  </li>
  <li>
    <p>Exploit Development</p>
  </li>
  <li>
    <p>Proprietary File Formats</p>
  </li>
</ul>

<h2 id="assumptions">Assumptions</h2>
<p>Before Proceeding It is important that the reader have some knowledge of the following concepts:</p>

<ol>
  <li>
    <p>Endianness</p>
  </li>
  <li>
    <p>Data structures</p>
  </li>
  <li>
    <p>Hexadecimal notation</p>
  </li>
  <li>
    <p>Intel Architecture</p>
  </li>
</ol>

<h1 id="assembly-language">Assembly Language</h1>
<p>A very low level programming language generated by compilers and translatable to
machine code directly. Offers more control but less abstraction and would
require alot of typing.</p>

<p>The goal is not to write programs in assembly code though i have written some
basic bootloaders with assembly you can check out the <a href="https://github.com/TralahM/explore_asm">project
here</a> but to be able to read and
understand disassembled code from a piece of software you want to reverse
engineer.</p>

<h2 id="the-stack-data-structure">The Stack Data Structure</h2>

<ul>
  <li>LIFO data structure</li>
</ul>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">push</span> <span class="n">ebp</span>
<span class="k">mov</span> <span class="n">esp</span><span class="p">,</span><span class="n">ebp</span>
<span class="k">sub</span> <span class="n">esp</span><span class="p">,</span><span class="mh">0x08</span>
<span class="k">mov</span> <span class="n">eax</span><span class="p">,</span><span class="mi">45</span>
<span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span><span class="mi">43</span>
<span class="k">add</span> <span class="n">eax</span><span class="p">,</span><span class="n">ebx</span>
<span class="k">call</span> <span class="n">sym_add</span>
<span class="k">ret</span>
</code></pre></div></div>

<h2 id="the-heap">The Heap</h2>

<p>Associated with Dynamic memory allocation</p>

<h2 id="the-bss-section">The BSS Section</h2>

<p>Contains all Uninitialized variables</p>

<h2 id="the-text-section">The Text Section</h2>

<p>Contains the actual executable instructions( code )</p>

<h2 id="the-registers">The Registers</h2>

<h3 id="general-purpose">General Purpose</h3>

<ol>
  <li><strong>EAX</strong> return values</li>
  <li><strong>EBX</strong> Base register for memory access</li>
  <li><strong>ECX</strong> Loop Counter</li>
  <li><strong>EDX</strong> Data Register for I/O</li>
</ol>

<h3 id="segment-registers">Segment Registers</h3>

<p>Usually are named with Two letter abbreviations</p>

<ol>
  <li>
    <p><strong>CS</strong> Stores code segment</p>
  </li>
  <li><strong>DS</strong> Stores Data segment</li>
  <li><strong>ES</strong>,<strong>FS</strong>,<strong>GS</strong> Far addressing (video mem etc)</li>
  <li><strong>SS</strong> Stack segment usually same as <strong>EDX</strong></li>
</ol>

<h3 id="indexes-and-pointers">Indexes and Pointers</h3>

<ol>
  <li><strong>EDI</strong> Destination index register for array ops</li>
  <li><strong>ESI</strong> Source index register array ops</li>
  <li><strong>EBP</strong> Base Pointer bottom of stack frame</li>
  <li><strong>ESP</strong> Stack Pointer top of stack frame</li>
  <li><strong>EIP</strong> Instruction Pointer to next instruction to be executed</li>
</ol>

<p>The <strong>E</strong> prefix is for 32-bit, 16-bit and 8-bit are without the E prefix
and finally for 64-bit the prefix is <strong>R</strong> instead of E however, forward
compatibility is maintained</p>

<h3 id="flags-register">Flags Register</h3>

<p>Holds 32 registers in total One bit values</p>

<ol>
  <li><strong>ZF</strong> Zero Flag Set to 1 if result of previous op is 0</li>
  <li><strong>SF</strong> Sign Flag Set to 1 if result of previous op is negative -</li>
</ol>

<h2 id="calling-conventions">Calling Conventions</h2>

<h3 id="cdecl">CDECL</h3>

<p>Arguments are passed on the stack in <strong>Right-to-Left</strong> order</p>

<p>Return Values are passed to <strong>EAX</strong></p>

<p>The Calling Function cleans the stack</p>

<p>Allowing for Variadic functions as caller knows the number of arguments</p>

<h3 id="stdcall-aka-winapi">STDCALL (AKA WINAPI)</h3>

<p>Arguments are passed on the stack in <strong>Right-to-Left</strong> order</p>

<p>Return Values are passed to <strong>EAX</strong></p>

<p>The Called Function cleans the stack</p>

<h3 id="fastcall">FASTCALL</h3>

<p>The first 2 or 3 (32-bit or smaller ) arguments are passed directly in
registers with the most commonly used registers being <strong>EDX</strong>, <strong>EAX</strong>, and <strong>ECX</strong> .</p>

<p>The Calling Function (usually) cleans the stack</p>

<h3 id="thiscall-c">THISCALL (C++)</h3>

<p>Only Non-Static Member Functions. Also Non-Variadic</p>

<p>The Pointer to the class object is passed in <strong>ECX</strong>, and return value is passed to <strong>EAX</strong>.</p>

<p>The Called Function cleans the Stack</p>

<h2 id="operand-types">OPERAND TYPES</h2>

<ul>
  <li>
    <p><strong>Immediates</strong> :03xf</p>
  </li>
  <li>
    <p><strong>Registers</strong> :EAX,.â€¦ECX the values themselves</p>
  </li>
  <li>
    <p><strong>Memory adrresses</strong> [0x80542a], [eax]</p>
  </li>
  <li>
    <p><strong>Offset Types</strong> by bytes [eax + 0x4]</p>
  </li>
  <li>
    <p><strong>Sibs</strong> which are offsets by multiplication and addition [ eax * 4 + ecx ] , [eax * 2 + ecx]</p>
  </li>
</ul>

<h3 id="ops">OPS</h3>

<ul>
  <li>
    <p><strong>mov</strong> Move destination, source reg,mem,immediate any combination</p>
  </li>
  <li>
    <p><strong>add</strong>,sub addition and subtraction</p>
  </li>
  <li>
    <p><strong>cmp</strong> compare subtract source from destination and assign a flag if ZF
is 1 the destination and source are equivalent</p>
  </li>
  <li>
    <p><strong>test</strong> test does bitwise and of source and destination and assigns a
flag to ZF or SF depending on the result</p>
  </li>
  <li>
    <p><strong>jcc</strong>/<strong>jmp</strong> conditional and regular jumps <strong>jz</strong>/<strong>jnz</strong> if <strong>ZF</strong> is zero or not
<strong>jump</strong> <strong>ja</strong>/<strong>jae</strong> jump above and jump above equal <strong>jb</strong>/<strong>jbe</strong>/<strong>bjnb</strong> jump below
and jump below equal</p>
  </li>
  <li>
    <p><strong>push</strong>/<strong>pop</strong> one operand and operate on stack</p>
  </li>
  <li>
    <p><strong>bitwise ops</strong> :   and, or , xor, not</p>
  </li>
</ul>

<h1 id="recognizing-programming-constructs">Recognizing Programming Constructs</h1>

<p><strong>Function Prologue and Epilogue</strong></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">push</span> <span class="n">ebp</span>
<span class="k">mov</span> <span class="n">ebp</span><span class="p">,</span> <span class="n">esp</span>
<span class="k">sub</span> <span class="n">esp</span><span class="p">,</span> <span class="n">N</span>

<span class="p">...</span>
<span class="k">mov</span> <span class="n">esp</span><span class="p">,</span><span class="n">ebp</span>
<span class="k">pop</span> <span class="n">ebp</span>
<span class="k">ret</span>
</code></pre></div></div>

<h2 id="about-call-and-ret">About CALL and RET</h2>
<p>Have an Implicit Operation</p>

<p><strong>Call</strong> will push EIP onto the Stack while  <strong>Return</strong> will
pop the EIP pointer from the stack</p>

<h2 id="loops">LOOPS</h2>

<p><strong>ECX</strong> is usually loop counter conditional jumps based on loop counter
easier to spot in call graphs</p>

<h2 id="switch-statements">SWITCH STATEMENTS</h2>
<p>jmp dwords endian formatted mem addressess with controlled offsets</p>

<h1 id="winding-up">Winding Up</h1>
<p>Hopefully now you are familiar with some basic assembly language syntax and are
now able to identify common programming structures like loops, switches,
functions etc from some disassembled binary code.</p>

<p>In the future we will look at how to get this assembly code from compiled
binaries as well as how to do some practical reverse engineering.</p>
:ET